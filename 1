package com.example.maze;

import android.app.Activity;
import android.content.Context;
import android.graphics.Canvas;
import android.graphics.Color;
import android.graphics.Paint;
import android.os.Handler;
import android.util.AttributeSet;
import android.view.MotionEvent;
import android.view.View;
import android.widget.Toast;

import androidx.annotation.Nullable;
import androidx.core.content.ContextCompat;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Locale;
import java.util.Random;
import java.util.Stack;


public class GameView extends View {

    // Use constants instead of hard-coded values
    private static final int COLS = 60;
    private static final int ROWS = 60;
    private static final float WALL_THICKNESS = 10;
    private static final float EXIT_MARGIN = 0;
    private static final float PLAYER_SIZE = 0;
    private static final float PLAYER_STEPS = 0;
    private static final int PLAYER_WATCH = 0;
    private static final int MAX_TIME = 60000; // số milliseconds tối đa cho người chơi

    private Cell[][] cells;
    private float cellSize, hMargin, vMargin, speed;
    boolean start = true, startStopwatch = false;

    private Random random;
    private Handler handler = new Handler();
    private int seconds;
    private Paint wallPaint, playerPaint, visitCell, exit;

    float x1 = 0;
    float y1 = 0;

    float playerPosX;
    float playerPosY;

    int countSteps = 0;
    int maxSteps = 0;
    Cell farestCell = new Cell(0,0 ,0);
    Cell playerCell = new Cell( 0, 0, 0);

    int width;
    int height;

    Context finalContext;

    Calendar start_time;


    public GameView(Context context, @Nullable AttributeSet attrs){
        super(context, attrs);

        finalContext = context;

        wallPaint = new Paint();
        wallPaint.setColor(ContextCompat.getColor(context, Constants.WALL_COLOR));
        wallPaint.setStrokeWidth(WALL_THICKNESS);

        playerPaint = new Paint();
        playerPaint.setColor(ContextCompat.getColor(context, Constants.RED_COLOR));
        playerPaint.setStrokeWidth(WALL_THICKNESS);

        visitCell = new Paint();
        visitCell.setColor(ContextCompat.getColor(context, Constants.GREEN_COLOR));
        visitCell.setStrokeWidth(WALL_THICKNESS);

        exit = new Paint();
        exit.setColor(Color.BLUE);
        exit.setStrokeWidth(20);
        exit.setStyle(Paint.Style.STROKE);

        random = new Random();

        // Use a separate method to initialize the cells array
        initCells(0);

        createMaze();
    }

    // Add a method to initialize the cells array
    private void initCells(int i) {
        cells = new Cell[COLS][ROWS];

        for (int x=0; x<COLS; x++)
        {
            for (int y=0; y<ROWS; y++)
            {
                cells[x][y] = new Cell(x, y ,0);
            }
        }
    }

    // Add a method to check if two cells are neighbours
    private boolean isNeighbour(Cell cell1, Cell cell2) {
        return Math.abs(cell1.col - cell2.col) + Math.abs(cell1.row - cell2.row) == 1;
    }

    // Add a method to remove the wall between two neighbour cells
    private void removeWall(Cell cell1, Cell cell2) {
        if (isNeighbour(cell1, cell2)) {
            if (cell1.col == cell2.col) {
                if (cell1.row > cell2.row) {
                    cell1.topWall = false;
                    cell2.bottomWall = false;
                } else {
                    cell1.bottomWall = false;
                    cell2.topWall = false;
                }
            } else {
                if (cell1.col > cell2.col) {
                    cell1.leftWall = false;
                    cell2.rightWall = false;
                } else {
                    cell1.rightWall = false;
                    cell2.leftWall = false;
                }
            }
        }
    }

    // Add comments to explain the purpose and operation of the methods and variables
    // Create a maze using a depth-first search algorithm
    private void createMaze() {
        Stack<Cell> stack = new Stack<>();
        Cell current, next;

        current = cells[0][0];
        current.visited = true;

        do {
            next = getNeighbour(current);
            if (next != null) {
                removeWall(current, next);
                stack.push(current);
                current = next;
                current.visited = true;
                countSteps++;
                current.stepsTo = countSteps;
            } else {
                current = stack.pop();
                countSteps--;
            }
        }while (!stack.empty());

    }

    // Get a random unvisited neighbour of a cell
    private Cell getNeighbour(Cell cell){
        ArrayList<Cell> neighbours = new ArrayList<>();

        // Check if the cell has a left neighbour
        if(cell.col > 0)
        {
            // Check if the left neighbour is unvisited
            if(!cells[cell.col-1][cell.row].visited){
                neighbours.add(cells[cell.col-1][cell.row]);
            }
        }

        // Check if the cell has a top neighbour
        if(cell.row > 0)
        {
            // Check if the top neighbour is unvisited
            if(!cells[cell.col][cell.row-1].visited){
                neighbours.add(cells[cell.col][cell.row-1]);
            }
        }

        // Check if the cell has a right neighbour
        if(cell.col < COLS-1)
        {
            // Check if the right neighbour is unvisited
            if(!cells[cell.col+1][cell.row].visited){
                neighbours.add(cells[cell.col+1][cell.row]);
            }
        }

        // Check if the cell has a bottom neighbour
        if(cell.row < ROWS-1)
        {
            // Check if the bottom neighbour is unvisited
            if(!cells[cell.col][cell.row+1].visited){
                neighbours.add(cells[cell.col][cell.row+1]);
            }
        }

        // Return a random neighbour from the list, or null if the list is empty
        if(neighbours.size() > 0){
            int index = random.nextInt(neighbours.size());
            return neighbours.get(index);
        }

        return null;
    }
    // Remove the wall between two neighbouring cells
    private void removeWall(Cell current, Cell next){
        // Check if the cells are in the same column
        if(current.col == next.col){
            // Check if the current cell is above the next cell
            if(current.row < next.row){
                // Remove the bottom wall of the current cell and the top wall of the next cell
                current.bottomWall = false;
                next.topWall = false;
            } else {
                // Remove the top wall of the current cell and the bottom wall of the next cell
                current.topWall = false;
                next.bottomWall = false;
            }
        }
        // Check if the cells are in the same row
        else if(current.row == next.row){
            // Check if the current cell is left of the next cell
            if(current.col < next.col){
                // Remove the right wall of the current cell and the left wall of the next cell
                current.rightWall = false;
                next.leftWall = false;
            } else {
                // Remove the left wall of the current cell and the right wall of the next cell
                current.leftWall = false;
                next.rightWall = false;
            }
        }
    }
    // Initialize the cells array with new cells
    private void initCells() {
        cells = new Cell[COLS][ROWS];

        for (int x=0; x<COLS; x++)
        {
            for (int y=0; y<ROWS; y++)
            {
                cells[x][y] = new Cell(x, y ,0);
            }
        }
    }

    // Draw the maze on the canvas
    @Override
    protected void onDraw(Canvas canvas) {
        canvas.drawColor(ContextCompat.getColor(getContext(), Constants.BACKGROUND_COLOR));

        int width = getWidth();
        int height = getHeight();

        if (width/height < COLS/ROWS)
            cellSize = width/(COLS+1);
        else
            cellSize = height/(ROWS+1);

        hMargin = (width-COLS*cellSize)/2;
        vMargin = (height-ROWS*cellSize)/2;

        canvas.translate(hMargin, vMargin);

        for(int x=0; x<COLS; x++){
            for(int y=0; y<ROWS; y++){
                if(cells[x][y].topWall){
                    canvas.drawLine(
                            x * cellSize,
                            y * cellSize,
                            (x + 1) * cellSize,
                            y * cellSize,
                            wallPaint);
                }

                if(cells[x][y].leftWall){
                    canvas.drawLine(
                            x * cellSize,
                            y * cellSize,
                            x * cellSize,
                            (y + 1) * cellSize,
                            wallPaint);
                }

                if(cells[x][y].bottomWall){
                    canvas.drawLine(
                            x * cellSize,
                            (y + 1) * cellSize,
                            (x + 1) * cellSize,
                            (y + 1) * cellSize,
                            wallPaint);
                }

                if(cells[x][y].rightWall){
                    canvas.drawLine(
                            (x + 1) * cellSize,
                            y * cellSize,
                            (x + 1) * cellSize,
                            (y + 1) * cellSize,
                            wallPaint);
                }
            }
        }
    }
    // Draw the player on the canvas
    private void drawPlayer(Canvas canvas) {
        float margin = cellSize / 10;

        playerPaint.setColor(ContextCompat.getColor(getContext(), Constants.RED_COLOR));

        canvas.drawCircle(
                (playerCell.col + 0.5f) * cellSize,
                (playerCell.row + 0.5f) * cellSize,
                cellSize / 2 - margin,
                playerPaint);

        playerPaint.setColor(ContextCompat.getColor(getContext(), Constants.WHITE_COLOR));

        canvas.drawCircle(
                (playerCell.col + 0.5f) * cellSize,
                (playerCell.row + 0.5f) * cellSize,
                cellSize / 2 - margin - PLAYER_SIZE,
                playerPaint);
    }

    // Draw the exit on the canvas
    private void drawExit(Canvas canvas) {
        float margin = cellSize / 10;

        canvas.drawRect(
                farestCell.col * cellSize + margin,
                farestCell.row * cellSize + margin,
                (farestCell.col + 1) * cellSize - margin,
                (farestCell.row + 1) * cellSize - margin,
                exit);
    }

    // Draw the visible cells on the canvas
    private void drawVisibleCells(Canvas canvas) {
        for(int x=0; x<COLS; x++){
            for(int y=0; y<ROWS; y++){
                if(cells[x][y].visible){
                    canvas.drawRect(
                            x * cellSize,
                            y * cellSize,
                            (x + 1) * cellSize,
                            (y + 1) * cellSize,
                            visitCell);
                }
            }
        }
    }
    // Draw the timer on the canvas
    private void drawTimer(Canvas canvas) {
        Paint textPaint = new Paint();
        textPaint.setColor(ContextCompat.getColor(getContext(), Constants.WHITE_COLOR));
        textPaint.setTextSize(50);
        textPaint.setTextAlign(Paint.Align.CENTER);

        int minutes = seconds / 60;
        int secs = seconds % 60;

        String time = String.format(Locale.getDefault(), "%02d:%02d", minutes, secs);

        canvas.drawText(time, getWidth() / 2, 50, textPaint);
    }

    // Update the timer every second
    private void updateTimer() {
        handler.postDelayed(new Runnable() {
            @Override
            public void run() {
                if (startStopwatch) {
                    seconds++;
                    updateTimer();
                }
            }
        }, 1000);
    }

    // Check if the player has reached the exit
    private void checkExit() {
        if (playerCell == farestCell) {
            startStopwatch = false;
            Toast.makeText(getContext(), "You win!", Toast.LENGTH_SHORT).show();
            ((Activity) finalContext).finish();
        }
    }
    // Handle the touch events on the screen
    @Override
    public boolean onTouchEvent(MotionEvent event) {
        if (event.getAction() == MotionEvent.ACTION_DOWN) {
            return true;
        }

        if (event.getAction() == MotionEvent.ACTION_MOVE) {
            float x = event.getX();
            float y = event.getY();

            float playerCenterX = hMargin + (playerCell.col + 0.5f) * cellSize;
            float playerCenterY = vMargin + (playerCell.row + 0.5f) * cellSize;

            float dx = x - playerCenterX;
            float dy = y - playerCenterY;

            float absDx = Math.abs(dx);
            float absDy = Math.abs(dy);

            if (absDx > cellSize || absDy > cellSize) {

                if (absDx > absDy) {
                    // Move left or right
                    if (dx > 0) {
                        // Move right
                        movePlayer(Direction.RIGHT);
                    } else {
                        // Move left
                        movePlayer(Direction.LEFT);
                    }
                } else {
                    // Move up or down
                    if (dy > 0) {
                        // Move down
                        movePlayer(Direction.DOWN);
                    } else {
                        // Move up
                        movePlayer(Direction.UP);
                    }
                }
            }

            return true;
        }

        return super.onTouchEvent(event);
    }

    // Move the player in a given direction if possible
    private void movePlayer(Direction direction) {
        switch (direction) {
            case UP:
                if (!playerCell.topWall) {
                    playerCell = cells[playerCell.col][playerCell.row - 1];
                }
                break;
            case DOWN:
                if (!playerCell.bottomWall) {
                    playerCell = cells[playerCell.col][playerCell.row + 1];
                }
                break;
            case LEFT:
                if (!playerCell.leftWall) {
                    playerCell = cells[playerCell.col - 1][playerCell.row];
                }
                break;
            case RIGHT:
                if (!playerCell.rightWall) {
                    playerCell = cells[playerCell.col + 1][playerCell.row];
                }
                break;
        }

        checkExit();
        invalidate();
    }

    public void setCOLS(int cols) {
    }

    public void setROWS(int rows) {
    }

    public void setPLAYER_STEPS(int speed) {
    }

    public void setPLAYER_WATCH(int watch) {
    }

    // An enum to represent the four possible directions
    enum Direction {
        UP, DOWN, LEFT, RIGHT;
    }
}
